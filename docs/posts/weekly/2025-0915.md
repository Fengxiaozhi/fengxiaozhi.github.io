# 2025/09/08-2025/09/14

## 复习-函数式编程
函数式编程是通过应用和组合函数来构建程序的一种规范，常见的两种概念有：
- 高阶函数
- 函数柯里化

高阶函数是比函数柯里化更细粒度的一种编程概念。一般指的是操作函数的函数。

常见有：
- 数组的操作方法 Array.map Array.filter等
- 函数返回一个函数 （经典闭包案例）

柯里化指的是把接收多参数的函数变成多个接收单参数的函数。
```
function addFn (a,b,c){
    return a + b + c
}
// 柯里化成
function addFn(a) {
    return function (b) {
        return function (c) {
            return a + b +c
        }
    }
}
```
调用就会从addFn(1,2,4) => addFn(1)(2)(3)。当然这只是简单的示例。

## 复习-垃圾回收机制
在日常编程中经常需要开创堆栈空间来做存储，如果在这过程中内存没有得到及时的释放就会造成内存溢出，所以需要垃圾回收（释放不需要的堆栈）。而垃圾回收可以手动回收但是这样会很容出错，所以引擎会采用自动回收机制来释放也就是自动GC。

主要有几种方式：
- 引用计数 （已废弃），无法解决循环引用计数的缺陷
- 标记清除法 （目前最要的方式）

标记清除法中会有一些优化的策略：
- 分代收集
- 增量收集
- 闲时回收
- 三色标记法

## 复习- promise
promise的设计是为了解决异步操作时需要层层传入的回调函数问题也称之为回调地狱。让回调的函数的代码更简洁直观，提高可读性与可维护性。

其内部核心主要3个状态,状态一旦改变则不可逆。
- pending 初始状态
- fulfilled 成功完成
- rejected 失败

常用的API
- Promise.all // 并发执行，所有promise变成fulfilled，才会fulfilled并返回所有的结果数组，一个rejected则立马rejected并返回rejected的结果
- Promise.allSetted // 并发执行，所有Promise都完成了才会返回，不管失败或者成功，返回所有的结果数组
- Promise.race // 任何一个改变状态则立马返回改promise的结果，不管失败或者成功
- Promise.any // 只要有一个变成fulfilled 则立马返回fulfilled的结果，否则全部rejected则结果rejected
- promise.resolve // 返回一个立马fulfilled的promise
- promise.rejece // 返回一个立马rejected的promise
- promise.try // ES2025为解决try catch promise异常而补充,让捕获异常代码更直观

## 复习- new的过程
new的过程也称之为实例化的过程，这里面主要做几件事：
- 创建一个新对象，并把原型指向函数的prototype属性
- 把构造函数的this指向这个新对象并执行它
- 如果函数返回一个对象则返回该对象否则返回新创建的对象

## 复习-继承
Javascript中并没有真正的对象编程，而继承无非是利用了原型/构造函数（本身）来模拟实现。
- 原型链继承
- 构造函数继承
- 寄生组合继承
不管是哪种继承核心都是利用以上几种方式，包括ES6的extends底层实现逻辑.

## 复习-闭包
闭包：一个函数作用域中保留了另外一个作用域中的变量访问能力，这是在代码编写时定下来的词法作用域。

场景：
- 类封装，类的方法访问了内部的变量，这个函数就是闭包
- 返回一个访问内部函数变量的函数，这个函数就是闭包
- 模块化
- 函数柯里化，把多个参数的函数拆分成一个个只有一个参数的函数，这些函数就是一个个闭包（保留上一个参数的访问）
- 经典循环输出，利用闭包解决

## 复习-截流防抖
截流：固定时间间隔内只执行一次
```
function throttle (fn , delay = 300) {
    let lastTime = 0

    return function (...args) {
        if(Date.now() - lastTime <= delay) {
            fn.apply(this, args)
            lastTime = Date.now()
        }
    }
}
```

防抖：可以触发多次，但是只会执行最后一次，延迟执行的时间固定，如果这段时间内再次触发会重新算时间间隔。
```
function debounce (fn , delay = 300) {
    let timeId = null
    return function (...args) {
        if(timeId)clearTimeout(timeId)
        timeId = setTimeout(function () {
            fn.apply(this, args)
        }, delay)
    }
}
```